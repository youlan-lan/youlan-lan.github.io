---
title: Vue源码解析之虚拟DOM和diff算法
date: 2021-10-27 00:53:45
index_img: https://images.unsplash.com/photo-1559252676-c735ac416188?ixid=MnwxMjA3fDB8MHxzZWFyY2h8MTV8fDF8ZW58MHx8MHxibHVlfA%3D%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=600&q=60
categories:
- vue
tags:
- vue
- 源码
---

**举个小栗子：**

我们要对一个屋子进行装修，装修图上只是对一部分空间进行改造，现有两种选择：①全拆了再按照装修图进行建造，②根据装修图，只对修改部分进行建造。

关于真实dom和虚拟dom的区别大致和上述例子相同，真实dom是①每一次修改都需要拆了之前的再新建，而虚拟dom是②通过比对不同，通过appendchild等来操作dom节点。

渲染真实dom的开销非常大，和页面性能优化中的重绘重排意义类似。当我们修改了页面中的某个数据，如果直接渲染到真实DOM中会引起整棵数的重绘重排, 如果我们使用虚拟dom，只让我们修改的数据映射到真实DOM, 做一个最少化重绘重排，这样的页面性能优化将大大提高。



## 虚拟dom

将真实的DOM的数据抽取出来，以对象的形式模拟树形结构

```js
<div>
    <p>你好</p>
</div>

// VNode:
const Vnode = {
    tag: 'div',
    children: [
        { tag: 'p', text: '你好' }
    ]
};
```

**1. h函数用来产生虚拟节点**

```js
const hFun = h('a', { props:{ href: 'http:baidu.com' } }, '百度');

// 将得到这样的虚拟节点:
{'sel': 'a','data': { props: { href: 'http:baidu.com' } }, 'text': '百度'};

// 得到的真正DOM节点
<a href = "http:baidu.com" >百度</a>
```

**2. 虚拟节点的属性**

`childred`	`data`	`elm`	`key`	`sel`	`text`

**3. h函数使用patch函数进行”上树“**

![image-20211026223413361](https://gitee.com/youlan_lan/md_image/raw/master/20211026223413.png)



## diff算法

简单的说：就是新旧虚拟dom 的比较，如果有差异就以新的为准，然后再插入的真实的dom中，重新渲染。

**1.  在diff中，key起着非常重要的作用**

* 无key：新的和旧的只会在进行头尾两端比较
* 有key：除了比较头尾两端，还会根据key生成对象`oldKeyToIdx`中查找匹配的节点

> 为节点设置key可以更高效的利用dom

例如：

在B和C之间加一个F，Diff算法默认执行起来是这样的：C更新成F，D更新成C，E更新成D，最后再插入E，这个效率emmm。。。。。。

如果我们给每个节点设置好key，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。

![img](https://gitee.com/youlan_lan/md_image/raw/master/20211027004427.png)

> 哦豁，for循环要设置key.....

**2. 特点**

- 只会做同级比较，不做跨级比较
- 比较后几种情况
  - `if (oldVnode === vnode)`，他们的引用一致，可以认为没有变化。
  - `if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text)`，文本节点的比较，需要修改，则会调用`Node.textContent = vnode.text`。
  - `if( oldCh && ch && oldCh !== ch )`, 两个节点都有子节点，而且它们不一样，这样我们会调用`updateChildren`函数比较子节点，这是diff的核心
  - `else if (ch)`，只有新的节点有子节点，调用`createEle(vnode)`，`vnode.el`已经引用了老的dom节点，`createEle`函数会在老dom节点上添加子节点。
  - `else if (oldCh)`，新节点没有子节点，老节点有子节点，直接删除老节点。

**3. 总结**

* 只有是同一个虚拟节点，才进行精细化比较，否则就是暴力删除旧的、插入新的
* 定义同一个虚拟节点：选择器系统 && key相同
* **key是节点的唯一标识**
* 只进行**同层**比较，不会进行跨层比较

* diff不是万能的，肯定有情况是做不到虚拟dom优化的

**4. 在实际开发中要注意**

- 尽量不要跨层级的修改dom
- 在开发组件时，保持稳定的 DOM 结构会有助于性能的提升
- 设置key可以让diff更高效
