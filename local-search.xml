<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【手把手傻瓜式系列2】 Fluid 主题配置教程</title>
    <link href="/2021/06/07/Hexo%20%E4%B8%BB%E9%A2%98%E4%B9%8B%20Fluid/"/>
    <url>/2021/06/07/Hexo%20%E4%B8%BB%E9%A2%98%E4%B9%8B%20Fluid/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-主题之-Fluid"><a href="#Hexo-主题之-Fluid" class="headerlink" title="Hexo 主题之 Fluid"></a>Hexo 主题之 Fluid</h1><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>Hexo搭建好的博客是使用<code>landscape</code>主题，看起来挺丑的….不是很喜欢，所以我们到hexo官网上寻找一些好看的主题进行更改。</p><blockquote><p>hexo主题网站： <a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></blockquote><p>这里有几百个主题供你选择，由于太多而且网站中也没有对这些主题进行筛选的功能，让人难以选择，所以我们推荐到github上寻找合适的主题：</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607132952.png" alt="github上的搜索"></p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607133049.png" alt="" style="zoom: 67%;" /><p>从而可以看出，最受欢迎的是<code>Next主题</code>，还有几个主题的star数也不少，大家根据自己的喜好挑选即可。</p><p>浅谈几个挑选合适主题的标准：</p><ul><li>star数、fork数多的</li><li>使用文档写的比较详细的</li><li>更新时间比较近的，或者更新频率比较高的</li></ul><h3 id="1-Fluid主题介绍"><a href="#1-Fluid主题介绍" class="headerlink" title="1. Fluid主题介绍"></a>1. Fluid主题介绍</h3><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607135407.png" alt="" style="zoom:67%;" /><p>这是一款 Material Design 风格的 Hexo 主题，以简约的设计帮助你专注于写作： <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607135202.png"></p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607135243.png"></p><p>整体上，简约风，个人是比较喜爱的。最重要的是这个主题的文档写得非常地详细，查起来非常容易，上手快。</p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><p>安装的话，github的README.md文档写的很清楚了</p><p>这里直接复制粘贴一下：</p><p><strong>方式一：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去。</p><p><strong>方式二：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-string">https://github.com/fluid-dev/hexo-theme-fluid.git</span><br></code></pre></td></tr></table></figure><p>或者直接下载压缩文件，解压后放到themes目录，将解压出来的文件夹命名为<code>fluid</code></p><h3 id="3-修改配置"><a href="#3-修改配置" class="headerlink" title="3. 修改配置"></a>3. 修改配置</h3><p>修改 Hexo 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h3 id="4-创建页"><a href="#4-创建页" class="headerlink" title="4. 创建页"></a>4. 创建页</h3><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-02-23 19:20:33</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><p><strong>分类页、标签类也类似</strong></p><p>创建了这两个页，在写文章的时候，在最前面写上对应的category、tags即可</p><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 使用Hexo搭建博客（基础版）<br>index<span class="hljs-emphasis">_img: https://gitee.com/youlan_</span>lan/md<span class="hljs-emphasis">_image/raw/master/20210607012255.png</span><br><span class="hljs-emphasis">categories:</span><br><span class="hljs-emphasis">- 博客搭建</span><br><span class="hljs-emphasis">tags:</span><br><span class="hljs-emphasis">- 博客搭建</span><br><span class="hljs-emphasis">- node</span><br><span class="hljs-emphasis">- git</span><br><span class="hljs-emphasis">- github</span><br><span class="hljs-emphasis">---</span><br></code></pre></td></tr></table></figure><p>具体的参数可以查阅官方文档： <a href="https://hexo.io/zh-cn/docs/front-matter">https://hexo.io/zh-cn/docs/front-matter</a></p><h3 id="5-一些基础配置"><a href="#5-一些基础配置" class="headerlink" title="5. 一些基础配置"></a>5. 一些基础配置</h3><p>本篇文章只介绍一些基础的配置，足够你搭建一个好看的博客。想要高级玩法请到fluid上查看指南~</p><p>打开<code>_config.fluid.yml</code>文件，这个文件已经很贴心的为我们写好了中文注释，大家根据自己的喜好进行配置即可~</p><p><strong>我们从上外下看吧</strong></p><h4 id="1-图标favicon"><a href="#1-图标favicon" class="headerlink" title="1. 图标favicon"></a>1. 图标favicon</h4><p>这个是用于浏览器标签的图标</p><p>也就是这个小东东</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607141316.png" alt="就是这个小东东"></p><p>favicon 和 apple_touch_icon设置成同一个就可以了</p><h4 id="2-代码高亮"><a href="#2-代码高亮" class="headerlink" title="2. 代码高亮"></a>2. 代码高亮</h4><p>这个部分可以默认，也可以根据你的喜好进行修改</p><h4 id="3-打字机效果fun-features"><a href="#3-打字机效果fun-features" class="headerlink" title="3. 打字机效果fun_features"></a>3. 打字机效果fun_features</h4><p>我这里把是否循环播放效果打开了，一直重复打字机的动画效果</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607141600.png"></p><h4 id="4-颜色color"><a href="#4-颜色color" class="headerlink" title="4. 颜色color"></a>4. 颜色color</h4><p>这里是对一些颜色的配置，可以直接默认，我这边是把<code>navbar_bg_color</code> 设置成和主页图片相近的颜色，这样视觉效果更好</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607141715.png"></p><h4 id="5-字体font"><a href="#5-字体font" class="headerlink" title="5. 字体font"></a>5. 字体font</h4><p>默认好像是16px，我觉得有点小了，改成19px比较合适</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607141845.png"></p><h4 id="6-懒加载lazyload"><a href="#6-懒加载lazyload" class="headerlink" title="6. 懒加载lazyload"></a>6. 懒加载lazyload</h4><p>这个打开，懒加载可以使得页面更加流畅，看不到的范围就先不加载，前端的小伙伴都懂~</p><p>这里有一个加载时的占位图片loading_img也可以设置一下</p><h4 id="7-导航栏navbar"><a href="#7-导航栏navbar" class="headerlink" title="7. 导航栏navbar"></a>7. 导航栏navbar</h4><p>主要设置的参数：</p><ul><li>blog_title</li><li>menu（一般这个默认就可以了）</li></ul><h4 id="8-搜索功能search"><a href="#8-搜索功能search" class="headerlink" title="8. 搜索功能search"></a>8. 搜索功能search</h4><p>打开这个，可以在网页里通过关键字搜索到博客内容</p><h4 id="9-页脚footer"><a href="#9-页脚footer" class="headerlink" title="9. 页脚footer"></a>9. 页脚footer</h4><p>根据自己的需要进行修改吧</p><p>我这边只修改了content和打开了statistics</p><p>content的内容需要使用<strong>HTML</strong>进行编写</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607142609.png"></p><h4 id="10-banner"><a href="#10-banner" class="headerlink" title="10 . banner"></a>10 . banner</h4><p>刚创建好的banner都是一样的图片，不太好看，我们先对banner进行配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/bg/example.jpg</span>   <span class="hljs-comment"># 对应存放在 /source/img/bg/example.jpg</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">banner_img:</span> <span class="hljs-string">https://static.zkqiang.cn/example.jpg</span><br></code></pre></td></tr></table></figure><p>推荐使用网络链接</p><blockquote><p>如果是本地图片，目录文件夹可自定义，但必须在 source 目录下，博客与主题的 source 目录最终会合并，因此优先选择博客的 source。</p><p>图片大小建议压缩到 1MB 以内，否则会严重拖慢页面加载。</p></blockquote><ol><li><p>index</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607142729.png" alt="index"></p><p>效果：</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607142806.png" alt="index"></p><p>里面有个api接口，感兴趣的小伙伴可以去了解了解，可以使用随机播放不同的text</p></li><li><p>文章页 Post Page</p><ul><li><p>default_index_img 文章默认图片，如果没有指定 index_img 时会使用该图片，若两者都为空则不显示任何图片</p></li><li><p>meta 这里有一些文章标题下方的元信息设置，根据自己的喜好设置就可以了，需要使用的功能就设置成 true 就行了</p></li><li><p>updated 一些关于更新后显示的信息</p></li><li><p>copyright 版权声明，同样的content里需要使用html格式</p></li><li><p>其他的就默认就好了，不是关键的功能</p></li></ul></li><li><p>其他页面</p><p>根据自己的喜好设置就好了，可以一路默认</p></li></ol><p><strong>主要是以下两个参数</strong></p><ul><li>banner_img</li><li>banner_img_height</li></ul><p>每个页面都可以配置一个banner_img，直接搜索<code>banner_img</code>快速定位进行修改</p><h3 id="6-config-yml"><a href="#6-config-yml" class="headerlink" title="6. _config.yml"></a>6. _config.yml</h3><p>这里的注释是英文的，可能看起来不是那么方便，这里主要是两个地方需要修改，其他直接默认就可以了</p><ol><li><p>最开头的网站信息</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607143908.png"></p></li><li><p>以及最末尾的部署设置</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607143912.png"></p></li></ol><p>这里可以配置二次元人物，具体就到网上搜索就好了~ 搜<code>live2 看板娘</code></p><h3 id="7-最后"><a href="#7-最后" class="headerlink" title="7.  最后"></a>7.  最后</h3><p>算是一个傻瓜式教程了。。。。省略了非常多的步骤。next听说可玩度很高，配置之后网页非常好看（但我不喜欢又关我什么事hhh），next的贡献者非常多，所以next主题的维护以及更新等等方面都非常地强。</p><p>但是！fluid的简约风真的非常nice！！！安利一波</p><h3 id="8-小彩蛋"><a href="#8-小彩蛋" class="headerlink" title="8. 小彩蛋"></a>8. 小彩蛋</h3><p>对了，在设置banner_img的时候，由于banner比较大，所以把图片放大之后非常地模糊。。。所以这个也让我浪费了非常多时间在找高清图以及增强图片清晰度的方法</p><ul><li><p>增强图片清晰度的方法： </p><ul><li><p>用ps：emmm….难度有点大，ps小白表示不想</p></li><li><p>一些ai图像修复网站：傻瓜式操作，还不错</p></li></ul></li><li><p>一些高清图片的网站</p><p>这个是我后来在fluid的博客上看到的…应该早点看到，泪目</p><ul><li><strong>元气桌面 <a href="https://desk.duba.com/">https://desk.duba.com/</a></strong></li><li><a href="https://wallpaperhub.app/">https://wallpaperhub.app/</a></li><li><a href="https://wallhaven.cc/">https://wallhaven.cc/</a></li><li><a href="https://unsplash.com/">https://unsplash.com/</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白教程</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【手把手傻瓜式系列1】使用Hexo搭建博客（基础版）</title>
    <link href="/2021/06/07/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/06/07/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Hexo搭建博客（基础版）"><a href="#使用Hexo搭建博客（基础版）" class="headerlink" title="使用Hexo搭建博客（基础版）"></a>使用Hexo搭建博客（基础版）</h1><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>就目前来说，有非常多平台可以发表自己的博客，像CSDN、简书、掘金等等，并且这些平台有一定的流量，一篇好的博客很快就能吸引来大量的浏览量。</p><ul><li>这些平台的优点很明显：操作简单，傻瓜式操作，可以进行交互。</li><li>但是也存在一些比较难受的缺点：平台的限制及一些广告，因违规而删除你的文章</li></ul><p>而去购买服务器来进行搭建博客又有点大费周折了，而且成本极高，不利于小白快速上手。</p><p>于是，使用博客框架以及github这一方式就介于上述两种之间。我们使用hexo框架，再将搭建好的博客依托到github page平台上。这样，我们只用专心于我们的写作了。</p><blockquote><p>github毕竟是国外的网，打开确实有点慢，而国内站点码云的<code>gitee page</code> 被暂停使用了……</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/20210607001959.png" alt="码云没了..."></p></blockquote><h3 id="1-Hexo的介绍"><a href="#1-Hexo的介绍" class="headerlink" title="1. Hexo的介绍"></a>1. Hexo的介绍</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>Hexo是基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。</p><blockquote><p>官方文档上的使用方法非常的详细，可以放心食用：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>本文只是摘取部分关键的步骤</p></blockquote><h3 id="2-使用hexo搭建博客的步骤"><a href="#2-使用hexo搭建博客的步骤" class="headerlink" title="2. 使用hexo搭建博客的步骤"></a>2. 使用hexo搭建博客的步骤</h3><ol><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>将hexo部署到GitHub</li><li>更改主题</li><li>设置个人域名</li><li>发布文章</li></ol><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h3><h5 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h5><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><h5 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2. 安装 Node.js"></a>2. 安装 Node.js</h5><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载。</p><blockquote><p>上述两个安装方法不是本次教程的重点，不会安装的小伙伴可以到网上搜一下教程~</p></blockquote><h5 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h5><p>安装好git之后，我们可以右击选择<code>Git Bash here</code>可以打开一个命令行窗口，输入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">-g</span> <span class="hljs-string">hexo-cli</span><br></code></pre></td></tr></table></figure><p>这是全局安装hexo脚手架，之后在这台电脑使用hexo搭建新的博客就不需要再次安装了</p><p>新建文件夹</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">init</span> <span class="hljs-string">&lt;folder&gt;</span><br><span class="hljs-string">$</span> <span class="hljs-string">cd</span> <span class="hljs-string">&lt;folder&gt;</span><br><span class="hljs-string">$</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br></code></pre></td></tr></table></figure><p>会生成很多文件夹，看不懂没关系，知道怎么配置就可以了。</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li><strong>_config.yml: 博客的配置文件</strong></li></ul><blockquote><p>关于文件里面的参数可以到官方文档上查看，这里不多说了。</p></blockquote><h5 id="4-启动"><a href="#4-启动" class="headerlink" title="4. 启动"></a>4. 启动</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">g</span><br><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">s</span><br></code></pre></td></tr></table></figure><p>这三个命令非常重要</p><p>在浏览器中输入<code>localhost:4000</code> 就可以看到生成的博客页面了</p><p><code>ctrl + c </code> 可以关掉服务</p><h3 id="4-创建GitHub仓库"><a href="#4-创建GitHub仓库" class="headerlink" title="4. 创建GitHub仓库"></a>4. 创建GitHub仓库</h3><p>GitHub非常好用，配合着git一起使用，主要用于团队协作和下载优秀者的代码</p><blockquote><p>详情可以自己去搜一搜</p></blockquote><p>先注册一个账号，创建一个 <code>yourusername.github.io</code>的仓库</p><blockquote><p>必须用这个名字，不然GitHub page不能识别你的文件</p></blockquote><p>生成SSH添加到GitHub</p><blockquote><p>这也不是我们本次教程的重点，具体步骤可以到网上搜搜教程，属于git的使用</p><p>只有把你电脑的ssh添加到你的GitHub上，你的git才能正常使用</p></blockquote><h3 id="5-将Hexo部署到GitHub上"><a href="#5-将Hexo部署到GitHub上" class="headerlink" title="5. 将Hexo部署到GitHub上"></a>5. 将Hexo部署到GitHub上</h3><p>找到配置文件 <code>_config.yml</code>，翻到最后，根据自己的仓库进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-comment"># YourgithubName需要改成你的GitHub账号名</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/YourgithubName/YourgithubName.github.io.git</span><br>  <span class="hljs-comment"># 这里是你的代码推送到的分支名</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>安装deploy-git：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">deploy</span><br><br><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">g</span> <span class="hljs-string">--d</span>   <span class="hljs-comment"># 一键部署</span><br></code></pre></td></tr></table></figure><p><code>hexo clean</code> 清除之前生成的东西<br><code>hexo generate</code> 生成静态文章，可以用 <code>hexo g</code> 缩写<br><code>hexo deploy</code> 部署文章，可以用 <code>hexo d</code> 缩写</p><p>部署成功后，在<a href="http://yourname.github.io/">http://yourname.github.io</a> 这个网站就可以访问到你的博客了</p><h3 id="6-更改主题"><a href="#6-更改主题" class="headerlink" title="6. 更改主题"></a>6. 更改主题</h3><p>到 <a href="https://hexo.io/themes/">https://hexo.io/themes/</a> 挑选自己喜欢的主题</p><p>推荐到GitHub上找star最多的几个主题，star多证明这一主题使用的人也多，相对地使用文档也会更加完整清晰，体验感更佳√</p><p>这里就不细讲了，后面会更新一篇使用<code>Fluid</code>主题的简易配置教程</p><blockquote><p>待更……</p></blockquote><h3 id="7-设置个人域名"><a href="#7-设置个人域名" class="headerlink" title="7. 设置个人域名"></a>7. 设置个人域名</h3><p>现在你的域名是<code>yourname.github.io</code>，但是感觉好像逼格不够……</p><p>hhh 所以，你可以根据自己的喜好买一个看起来牛逼的域名</p><p>到阿里云上购买一个域名，不同的后缀价格不太一样，可以选择一个便宜的域名玩玩，看你的选择咯。</p><p>买到域名之后，需要进行实名认证，然后再到域名控制台中，找到你买的域名，点击解析，添加解析。</p><blockquote><p>解析线路选择默认，不要选择境外</p></blockquote><p>买好之后进入你的仓库，在settings中设置Custom domain，输入你的域名。</p><p>接着，你在你的博客文件source中创建一个名为<code>CNAME</code>文件，不用后缀，写上你的域名</p><p>然后再使用那几个命令进行部署就可以了</p><h3 id="8-发布文章"><a href="#8-发布文章" class="headerlink" title="8. 发布文章"></a>8. 发布文章</h3><p>创建一个新的文件，然后在source/_post中打开markdown文件，就可以开始编辑了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">newpapername</span><br></code></pre></td></tr></table></figure><p>写完之后，使用那三个命令进行部署</p><p>建议安装vscode，vscode带有命令行窗口非常方便，再下载一个<code>Markdown Preview Enhanced</code>插件，可以实时查看Markdown文件书写的效果图</p><h3 id="9-最后"><a href="#9-最后" class="headerlink" title="9. 最后"></a>9. 最后</h3><p>最重要的两个命令:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br><span class="hljs-string">$</span> <span class="hljs-string">hexo</span> <span class="hljs-string">g</span> <span class="hljs-string">--d</span><br></code></pre></td></tr></table></figure><p>建议新人先使用这种方式手动部署</p><p>待以后对GitHub等工具更为了解之后，可以使用GitHub page的自动部署功能</p><blockquote><p>待更……</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小白教程</tag>
      
      <tag>博客搭建</tag>
      
      <tag>node</tag>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典排序算法</title>
    <link href="/2021/06/06/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/06/06/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="经典排序算法"><a href="#经典排序算法" class="headerlink" title="经典排序算法"></a>经典排序算法</h1><h2 id="0-放在前面"><a href="#0-放在前面" class="headerlink" title="0. 放在前面"></a>0. 放在前面</h2><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/image-20210414224115837.png" alt="image-20210414224115837"></p><p><img src="https://cdn.kakkk.cc/img/371-1.jpg?imageView2/1/w/1280/h/488#" alt="img"></p><h2 id="1-冒泡排序（重点）"><a href="#1-冒泡排序（重点）" class="headerlink" title="==1. 冒泡排序（重点）=="></a>==1. 冒泡排序（重点）==</h2><p>比较相邻的元素，前面&gt;后面，则调换位置</p><p>所有元素都进行这一操作</p><p>需要用到两个for循环</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/giphy.gif"></p><ul><li><p>时间复杂度：</p><ul><li>最好情况：O(n)</li><li>平均情况：O(n^2)</li><li>最坏情况：O(n^2)</li></ul></li><li><p>稳定性：稳定</p></li><li><p>额外的空间：O(1)</p><p>原地排序，不需要额外空间</p></li></ul><h3 id="1-一般版"><a href="#1-一般版" class="headerlink" title="1. 一般版"></a>1. 一般版</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort1</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> len = arr.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;len-<span class="hljs-number">1</span>-i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;      <span class="hljs-comment">//相邻元素两两对比</span><br>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];  <span class="hljs-comment">//元素交换</span><br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-改进版"><a href="#2-改进版" class="headerlink" title="2. 改进版"></a>2. 改进版</h3><p>设置pos，记录每轮排序中最后一次进行交换的位置。下一轮排序只扫描到pos位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort2</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> i = arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>;  <span class="hljs-comment">//每一轮都初始化pos值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;      <span class="hljs-comment">//相邻元素两两对比</span><br>                pos = j; <span class="hljs-comment">//记录交换的位置</span><br>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];  <span class="hljs-comment">//元素交换</span><br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>        i = pos;  <span class="hljs-comment">//为下一趟做准备</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-双向冒泡"><a href="#3-双向冒泡" class="headerlink" title="3. 双向冒泡"></a>3. 双向冒泡</h3><p>正向和反向两遍冒泡</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort3</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> high = arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(low&lt;high) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=low;j&lt;high;++j)&#123;  <span class="hljs-comment">//正向冒泡，找到最大值</span><br>            <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123; <br>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>        --high;  <span class="hljs-comment">//为下面的循环做准备</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=high;j&lt;low;--j)&#123;  <span class="hljs-comment">//反向冒泡，找到最小值</span><br>            <span class="hljs-keyword">if</span>(arr[j]&lt;arr[j+<span class="hljs-number">1</span>])&#123; <br>                <span class="hljs-keyword">var</span> temp = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>在序列中找到最小/最大值，放到序列起始位置</p><p>对所有未排序的元素进行相同的操作，每轮只找最小/最大值</p><blockquote><p>选择排序 vs 冒泡排序：</p><ul><li>选择排序是记录这一轮遍历数组里的最小/最大值，遍历完成后将这个最值放在起始位置，只需要一次交换</li><li>冒泡排序是两两之间进行交换，需要交换很多次</li></ul></blockquote><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/%E9%80%89%E6%8B%A9px.gif" alt="选择px"></p><ul><li><p>时间复杂度：</p><ul><li>最好情况：O(n^2)</li><li>平均情况：O(n^2)</li><li>最坏情况：O(n^2)</li></ul></li><li><p>稳定性：不稳定</p><blockquote><p>大小相同的两个元素，相对前后位置对换了</p><p>比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p></blockquote></li><li><p>额外的空间：O(1)</p></li></ul><h3 id="1-简单选择排序（基本）"><a href="#1-简单选择排序（基本）" class="headerlink" title="1. 简单选择排序（基本）"></a>1. 简单选择排序（基本）</h3><h4 id="1-1-取下标"><a href="#1-1-取下标" class="headerlink" title="1-1 取下标"></a>1-1 取下标</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> len = arr.length;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=i;j&lt;len;j++) &#123;<br>      <span class="hljs-keyword">let</span> min = i;<br>      <span class="hljs-comment">//从剩下项中去寻找最小项，遇到比假设项小的就把其当作最小项继续寻找，直到找完剩下的所有项</span><br>      <span class="hljs-keyword">if</span> (arr[min] &gt; arr[j]) &#123; <span class="hljs-comment">// 寻找最小数下标</span><br>        min = j;  <span class="hljs-comment">//取出索引，下面进行判断，不相等就开始交换</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (min !== i) &#123;<br>        <span class="hljs-keyword">let</span> temp = arr[i];<br>        arr[i] = arr[min];<br>        arr[min] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-取值"><a href="#1-2-取值" class="headerlink" title="1-2 取值"></a>1-2 取值</h4><p>和上面的方法类似，只不过这里是直接拿数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; ++i) &#123;<br>    <span class="hljs-keyword">let</span> min = arr[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (min &gt; arr[j]) &#123;<br>        <span class="hljs-keyword">let</span> temp = min;<br>        min = arr[j];<br>        arr[j] = temp;<br>      &#125;<br>    &#125;<br>    arr[i] = min;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-堆排序（重点）"><a href="#2-堆排序（重点）" class="headerlink" title="==2. 堆排序（重点）=="></a>==2. 堆排序（重点）==</h3><ol><li>堆概念</li></ol><p>大顶堆：每个节点的值都大于或者等于它的左右子节点的值。</p><p>小顶堆：每个节点的值都小于或者等于它的左右子节点的值。</p><img src="https://gitee.com/youlan_lan/md_image/raw/master/image-20210418171723516.png" alt="image-20210418171723516" style="zoom:50%;" /><ol start="2"><li>具体操作</li></ol><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></p><ol><li><p>最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</p></li><li><p>创建最大堆：将堆中的所有数据重新排序</p></li><li><p>堆排序：移除位在第一个数据的根节点，并做最大堆调整的递归运算 </p></li></ol><ul><li><p>时间复杂度：</p><ul><li>最好情况：O(nlgn)</li><li>平均情况：O(nlgn)</li><li>最坏情况：O(nlgn)</li></ul></li><li><p>稳定性：不稳定</p></li><li><p>额外的空间：O(1)</p><p>每次只对一个元素操作，就地排序</p><p>==(↓ 下面代码是复制粘贴过来的，先放着吧)==</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildMaxHeap</span>(<span class="hljs-params">arr</span>) </span>&#123;   <span class="hljs-comment">//建堆</span><br>    <span class="hljs-keyword">var</span> len = arr.length;<br>    <span class="hljs-comment">// [n/2-1]表示的是最后一个有子节点 (本来是n/2（堆从1数起），但是这里arr索引是从0开始，所以-1)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-built_in">Math</span>.floor(len/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>        maxHeapify(arr, i);<br>    &#125;<br>    <span class="hljs-comment">//对每一个节点（非叶节点），做堆调整</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxHeapify</span>(<span class="hljs-params">arr, i</span>) </span>&#123;     <span class="hljs-comment">//堆调整</span><br>    <span class="hljs-keyword">var</span> left = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>,  <br>        right = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>, <br>        largest = i;   <span class="hljs-comment">//i为该子树的根节点</span><br>    <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;  <br>        largest = left;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;<br>        largest = right;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (largest !== i) &#123;  <span class="hljs-comment">//即上面的if中有一个生效了</span><br>        swap(arr, i, largest);  <span class="hljs-comment">//交换最大的为父节点</span><br>        maxHeapify(arr, largest);  <span class="hljs-comment">//交换后，原值arr[i]（往下降了）（索引保存为largest），</span><br>        <span class="hljs-comment">//作为根时，子节点可能比它大，因此要继续调整</span><br>    &#125;  <br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> temp = arr[i];  <br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    buildMaxHeap(arr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = arr.length-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        swap(arr, <span class="hljs-number">0</span>, i);<br>        len--;<br>        maxHeapify(arr, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><p>从第二位开始抽</p><p>抽出一个数，往前一位从后往前以此进行比对，找到比这个数小的数时则放其后（其实不就是打扑克排牌时的做法嘛）</p><p>1）从第一个元素开始，该元素可以被认为已经被排序<br>2）取出下一个元素，在已经排好序的序列中从后往前扫描<br>3）直到找到小于或者等于该元素的位置<br>4）将该位置后面的所有已排序的元素从后往前依次移一位<br>5)将该元素插入到该位置<br>6)重复步骤2~5</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p><ul><li><p>时间复杂度：</p><ul><li>最好情况：O(n)  输入的数组是升序排序</li><li>平均情况：O(n^2)</li><li>最坏情况：O(n^2)  输入的数组是降序排序</li></ul></li><li><p>稳定性：稳定</p><p>相等元素的相对次序没有改变</p></li><li><p>额外的空间：O(1)</p></li></ul><h3 id="1-直接插入排序（基本）"><a href="#1-直接插入排序（基本）" class="headerlink" title="1. 直接插入排序（基本）"></a>1. 直接插入排序（基本）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InsertionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;arr.length;i++)&#123;<br>        <span class="hljs-keyword">let</span> temp = arr[i];  <span class="hljs-comment">//抽出一个数</span><br>        <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;    <span class="hljs-comment">//往前一位进行比对</span><br>        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j]&gt;arr[i])&#123;<br>            arr[j+<span class="hljs-number">1</span>] = arr[j];  <span class="hljs-comment">//如果前一位的数大于取出来的数，则arr[j]外后移一位</span><br>            j--；   <span class="hljs-comment">//继续往前移动</span><br>        &#125;   <span class="hljs-comment">//当j&lt;0时，循环结束</span><br>        a[j+<span class="hljs-number">1</span>] = b; <span class="hljs-comment">//此时把取出的元素插进去</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-二分插入排序"><a href="#2-二分插入排序" class="headerlink" title="2. 二分插入排序"></a>2. 二分插入排序</h3><p>使用二分查找法，实际上就是在上面的方法中更改了查找位置</p><p>在已排序序列中二分查找到第一个比它大的数的位置</p><p>时间复杂度：</p><ul><li>最好情况：<strong>O(nlogn)</strong></li><li>平均情况：O(n^2)</li><li>最坏情况：O(n^2)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryInsertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;arr.length; i++) &#123;<br>        <span class="hljs-keyword">var</span> temp=arr[i],left=<span class="hljs-number">0</span>,right=i-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;       <span class="hljs-comment">//在已排序的元素中二分查找第一个比它大的值</span><br>          <span class="hljs-keyword">var</span> mid= <span class="hljs-built_in">parseInt</span>((left+right)/<span class="hljs-number">2</span>); <span class="hljs-comment">//二分查找的中间值</span><br>          <span class="hljs-keyword">if</span>(temp&lt;arr[mid])&#123; <span class="hljs-comment">//当前值比中间值小,则在左边的子数组中继续寻找   </span><br>            right = mid-<span class="hljs-number">1</span>;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>            left=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//当前值比中间值大,在右边的子数组继续寻找</span><br>          &#125;<br>        &#125;              <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=i-<span class="hljs-number">1</span>;j&gt;=left;j--)&#123;<br>          arr[j+<span class="hljs-number">1</span>]=arr[j];<br>        &#125;<br>        arr[left]=temp;<br>      &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="3-希尔排序（了解）"><a href="#3-希尔排序（了解）" class="headerlink" title="3. 希尔排序（了解）"></a>3. <a href="https://blog.csdn.net/l_ppp/article/details/108855298?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161873006716780255267245%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161873006716780255267245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-108855298.pc_search_result_hbase_insert&utm_term=%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>（了解）</h3><p>缩小增量排序</p><p>尽可能让小的值往前靠，让大的值靠后（避免大幅度的后移）</p><ol><li>设置一个增量n，这个n为数组长度的1/2</li><li>相隔n个的元素视为同一组，在组内进行比较排序</li><li>再将n*1/2，重复2步骤，直到增量n为1（此时所有元素都是同一个组了）</li></ol><img src="https://gitee.com/youlan_lan/md_image/raw/master/20200928201404153.gif" alt="在这里插入图片描述" style="zoom:50%;" /><p>（↓ 下面的代码是复制博客里的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> interval = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 不断地缩小间隔的大小，进行分组插入排序</span><br>    <span class="hljs-keyword">while</span>(interval &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 从 arr[interval] 开始往后遍历，将遍历到的数据与其小组进行插入排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = interval; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">let</span> temp = arr[i];<br>            <span class="hljs-keyword">let</span> j = i;<br>            <span class="hljs-keyword">while</span>(arr[j - interval] &gt; temp &amp;&amp; j - interval &gt;= <span class="hljs-number">0</span>) &#123;<br>                arr[j] = arr[j - interval];<br>                j -= interval ;<br>            &#125;<br>            arr[j] = temp;       <br>        &#125;<br>        <span class="hljs-comment">// 缩小间隔</span><br>        interval = <span class="hljs-built_in">Math</span>.floor(interval / <span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-快速排序（重点）"><a href="#4-快速排序（重点）" class="headerlink" title="==4. 快速排序（重点）=="></a>==4. 快速排序（重点）==</h2><p>将数据分成两部分</p><p>一边的数据全都小于基准数，一边的数据全都大于基准数</p><p>按照这种方法再分别对这两部分的数据进行快速排序</p><img src="https://gitee.com/youlan_lan/md_image/raw/master/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序" style="zoom:50%;" /><blockquote><p> 第一轮之后的效果：</p><img src="https://gitee.com/youlan_lan/md_image/raw/master/image-20210418203839596.png" alt="image-20210418203839596" style="zoom:40%;" /></blockquote><ul><li><p>时间复杂度：</p><ul><li>最好情况：O(nlogn)</li><li>平均情况：O(nlogn)</li><li>最坏情况：O(n^2)</li></ul></li><li><p>稳定性：不稳定</p></li><li><p>额外的空间：O(logn)~O(n)</p><p>递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度</p></li></ul><h3 id="1-有递归版本"><a href="#1-有递归版本" class="headerlink" title="1. 有递归版本"></a>1. 有递归版本</h3><blockquote><p>递归是什么？ ==&gt; 套娃</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quick</span>(<span class="hljs-params">arr, left = <span class="hljs-number">0</span>, right = arr.length - <span class="hljs-number">1</span></span>) </span>&#123; <br><span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> arr;  <span class="hljs-comment">//arr长度为0或1的时候</span><br><span class="hljs-keyword">var</span> i = left, j = right, basic =i;<br><span class="hljs-keyword">while</span>(i &lt; j) &#123;<br><span class="hljs-keyword">while</span>(arr[j] &gt;= arr[basic] &amp;&amp; j &gt; basic) j--;<span class="hljs-comment">//如果j指针指向的值大于或等于基准，则j指针向左移动</span><br><span class="hljs-keyword">while</span>(arr[i] &lt;= arr[basic] &amp;&amp; i &lt; j) i++;  <span class="hljs-comment">//同样的，如果i指针指向的值小于或等于基准，则i指针向右移动</span><br><span class="hljs-keyword">var</span> temp = arr[basic];  <span class="hljs-comment">//此时ij相遇，与基准数交换</span><br>arr[basic] = arr[j];<br>arr[j] = temp;<br>basic = i<br>&#125;<br>quick(arr, left, basic - <span class="hljs-number">1</span>); <span class="hljs-comment">//对左边进行</span><br>quick(arr, basic + <span class="hljs-number">1</span>, right); <span class="hljs-comment">//对右边进行</span><br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于使用了递归，所以要有条件，不然会无限套娃，然后就崩了 =。=</p><h3 id="2-无递归版本（栈）"><a href="#2-无递归版本（栈）" class="headerlink" title="2. 无递归版本（栈）"></a>2. 无递归版本（栈）</h3><blockquote><p>先来了解一下栈：大概可以比喻成 ==&gt; 把东西往容器里放，拿出来的时候只能是最后放的那个</p><ul><li>栈声明一些方法。<ul><li>push(element(s))： 添加一个（或几个）新元素到栈顶</li><li>pop()：移除栈顶的元素，同时返回被移除的元素</li><li>peek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</li><li>isEmpty()：如果栈里没有任何元素就返回true，否则返回false</li><li>clear()：移除栈里的所有元素</li><li>size()：返回栈里的元素个数。该方法和数组的length 属性很类似</li></ul></li></ul></blockquote><p>模拟栈，将待排序数组的[left,right]保存到数组中，循环取出进行快排</p><p>(↓贴个代码，看懂了，不会写)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> stack = [];  <span class="hljs-comment">//栈</span><br>    stack.push([<span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>]);  <span class="hljs-comment">//push()添加元素到栈顶</span><br>    <span class="hljs-keyword">while</span> (stack.length) &#123;<br>      <span class="hljs-keyword">let</span> list = stack.pop();  <span class="hljs-comment">//pop()移除栈顶元素，同时返回被移除的元素</span><br>      <span class="hljs-keyword">let</span> i = left = list[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">let</span> j = right = list[<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">let</span> mid = arr[(i + j) &gt;&gt; <span class="hljs-number">1</span>];  <span class="hljs-comment">//右移</span><br>      <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">while</span> (arr[i] &lt; mid) ++i;<br>        <span class="hljs-keyword">while</span> (arr[j] &gt; mid) --j;<br>        <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>          <span class="hljs-keyword">let</span> temp = arr[i];  <span class="hljs-comment">//交换</span><br>          arr[i] = arr[j];<br>          arr[j] = temp;<br>          ++i;<br>          --j;<br>        &#125;<br>      &#125; <span class="hljs-keyword">while</span> (i &lt;= j);<br>      <span class="hljs-keyword">if</span> (i &lt; right) stack.push([i, right]);<br>      <span class="hljs-keyword">if</span> (left &lt; j) stack.push([left, j]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-归并排序（重点）"><a href="#5-归并排序（重点）" class="headerlink" title="==5. 归并排序（重点）=="></a>==5. 归并排序<strong>（重点）</strong>==</h2><p>分而治之</p><p>将数组分组至两两比较，最后直到所有元素都被分到一组里</p><p><img src="https://gitee.com/youlan_lan/md_image/raw/master/1038932-20180630211441031-350251983.png" alt="img"></p><ul><li>时间复杂度：<ul><li>最好情况：O(nlogn)</li><li>平均情况：O(nlogn)</li><li>最坏情况：O(nlogn)</li></ul></li><li>稳定性：稳定</li><li>额外的空间：O(n)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">mergeSort = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span>(arr.length&lt;=<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">return</span> arr;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">var</span> mid=<span class="hljs-built_in">Math</span>.floor(arr.length/<span class="hljs-number">2</span>);  <span class="hljs-comment">//取中间值（向下取整）</span><br><span class="hljs-keyword">var</span> left=arr.slice(<span class="hljs-number">0</span>,mid);  <span class="hljs-comment">//分成左右两部分</span><br><span class="hljs-keyword">var</span> right=arr.slice(mid);<br>left = mergeSort(left);<br>right = mergeSort(right);<br><span class="hljs-keyword">var</span> temp=[];  <span class="hljs-comment">//一个空数组</span><br><span class="hljs-keyword">while</span>(left.length &amp;&amp; right.length)&#123;  <span class="hljs-comment">//左右两部分长度均存在</span><br><span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>] &lt; right[<span class="hljs-number">0</span>])&#123;  <span class="hljs-comment">//比较两个数的大小，先把小的放进去</span><br>temp.push(left.shift()); <span class="hljs-comment">//shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>temp.push(right.shift());<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>  temp.concat(left,right);  <span class="hljs-comment">//用递归继续进行分割，用concat进行合并</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-基数排序（了解）"><a href="#6-基数排序（了解）" class="headerlink" title="6. 基数排序（了解）"></a>6. 基数排序（了解）</h2><p>从个位数开始，依次放入0~9的桶中，再依次拿出来排序；十位、千位……重复上述操作，一直排到最高位为止</p><img src="https://gitee.com/youlan_lan/md_image/raw/master/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序" style="zoom: 50%;" /><ul><li>时间复杂度：<ul><li>最好情况：O(n+k)</li><li>平均情况：O(n+k)</li><li>最坏情况：O(n+k)</li></ul></li><li>稳定性：稳定</li><li>额外的空间：O(n+k)</li></ul><p>（贴一个大佬的代码，写法有点帅）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">radixSort = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">let</span> maxDigit = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.max(...arr))).length <span class="hljs-comment">// 取最大位数</span><br>    <span class="hljs-keyword">let</span> mod = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> dev = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> counter = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">let</span> bucket = <span class="hljs-built_in">parseInt</span>((arr[j] % mod) / dev);  <span class="hljs-comment">// 123%10/1=3；123%100/10=2；==&gt; 取位</span><br>            counter[bucket] = counter[bucket] == <span class="hljs-literal">null</span> ? [] : counter[bucket];<br>            counter[bucket].push(arr[j]);<br>        &#125;<br>        <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; counter.length; j++) &#123;<br>            <span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span>(counter[j]!=<span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">while</span> ((value = counter[j].shift()) != <span class="hljs-literal">null</span>) &#123;<br>                    arr[pos++] = value;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
